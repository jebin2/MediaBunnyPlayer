const DB_NAME="MediaLibraryDB",DB_VERSION=1,STORE_NAME="media";class IndexedDBHelper{constructor(){this.db=null}async init(){return new Promise((e,t)=>{const r=indexedDB.open(DB_NAME,1);r.onerror=()=>t(r.error),r.onsuccess=()=>{this.db=r.result,e(this.db)},r.onupgradeneeded=e=>{const t=e.target.result;if(!t.objectStoreNames.contains("media")){const e=t.createObjectStore("media",{keyPath:"id"});e.createIndex("type","type",{unique:!1}),e.createIndex("dateAdded","dateAdded",{unique:!1})}}})}async addMedia(e){return this.db||await this.init(),new Promise((t,r)=>{const n=this.db.transaction(["media"],"readwrite").objectStore("media").add(e);n.onsuccess=()=>t(e.id),n.onerror=()=>r(n.error)})}async getMedia(e){return this.db||await this.init(),new Promise((t,r)=>{const n=this.db.transaction(["media"],"readonly").objectStore("media").get(e);n.onsuccess=()=>t(n.result),n.onerror=()=>r(n.error)})}async getAllMediaByType(e){return this.db||await this.init(),new Promise((t,r)=>{const n=this.db.transaction(["media"],"readonly").objectStore("media").index("type").getAll(e);n.onsuccess=()=>t(n.result),n.onerror=()=>r(n.error)})}async deleteMedia(e){return this.db||await this.init(),new Promise((t,r)=>{const n=this.db.transaction(["media"],"readwrite").objectStore("media").delete(e);n.onsuccess=()=>t(),n.onerror=()=>r(n.error)})}async updateMediaThumbnail(e,t){return this.db||await this.init(),new Promise((r,n)=>{const i=this.db.transaction(["media"],"readwrite").objectStore("media"),s=i.get(e);s.onsuccess=()=>{const e=s.result;if(e){e.thumbnail=t,e.thumbnailGenerated=!0;const s=i.put(e);s.onsuccess=()=>r(),s.onerror=()=>n(s.error)}else n(new Error("Media item not found"))},s.onerror=()=>n(s.error)})}}export const dbHelper=new IndexedDBHelper;